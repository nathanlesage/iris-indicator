/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts"
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_SUPPORTED_SEGMENTS: () => (/* binding */ MAX_SUPPORTED_SEGMENTS),\n/* harmony export */   setupIrisIndicator: () => (/* binding */ setupIrisIndicator)\n/* harmony export */ });\n/* harmony import */ var _iris_indicator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iris-indicator */ \"./src/iris-indicator.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n\n\n// We derive the rendering resolution from the device pixel ratio (which often\n// is either 1 or 2). To make it a bit simpler to see, we only allow powers of\n// two.\nfunction normalizedDPR() {\n    let dpr = Math.ceil(window.devicePixelRatio);\n    if ([1, 2, 4, 8, 16].includes(dpr)) {\n        return dpr;\n    }\n    if (dpr > 16) {\n        return 16;\n    }\n    else if (dpr > 8) {\n        return 8;\n    }\n    else if (dpr > 4) {\n        return 4;\n    }\n    else if (dpr > 2) {\n        return 2;\n    }\n    else {\n        return 1;\n    }\n}\n// Some defaults that the user can adjust\nconst globalState = {\n    fpsLimit: 30, // Automatically limit to 30fps to keep the work simple\n    enableFpsLimit: true, // Enable FPS limiter\n    // Provide default colors\n    segmentColors: ['red', 'green', 'blue', 'purple'],\n    // Start with one blue element\n    segmentCounts: [0, 0, 1, 0],\n    // Default segment adjustment step duration for the animation\n    segmentAdjustmentStepDuration: 200,\n    // Enable the auto-simulation\n    simulation: true,\n    // Very slow rotation speed\n    rotationSpeed: 240,\n    // Very slow ray speed\n    raySpeed: 5,\n    // Enable bloom and set to a moderate intensity\n    bloomEnabled: true,\n    bloomIntensity: 2,\n    // Enable MSAA\n    enableMSAA: true,\n    // Set a default rendering resolution to the actual device pixels (not\n    // downsampled ones as is common on very high DPI displays)\n    renderingResolution: normalizedDPR()\n};\n// This is hardcoded in the fragment shader\nconst MAX_SUPPORTED_SEGMENTS = 4;\n/**\n * Creates a new iris indicator to render within the provided Canvas element.\n *\n * @param   {HTMLCanvasElement}  canvas  The target canvas element\n */\nfunction setupIrisIndicator(canvas) {\n    const gl = canvas.getContext('webgl2', { antialias: false, alpha: true });\n    if (gl === null) {\n        alert(\"Unable to initialize WebGL.\");\n        return;\n    }\n    const indicator = new _iris_indicator__WEBPACK_IMPORTED_MODULE_0__.IrisIndicator(gl);\n    // Setup a demo-UI\n    (0,_ui__WEBPACK_IMPORTED_MODULE_1__.setupUI)(indicator, globalState);\n    // Start simulation provider\n    setInterval(() => simulationStep(indicator), 1000);\n    // Start FPS counter\n    const fpsCounter = document.querySelector('#fps-counter');\n    setInterval(() => {\n        if (fpsCounter !== null) {\n            const fps = Math.round(indicator.getCurrentFps());\n            fpsCounter.textContent = `Rendering speed: ${String(fps)} fps`;\n        }\n    }, 100);\n    // Initialize state\n    indicator.setBloomEnabled(globalState.bloomEnabled);\n    indicator.setBloomIntensity(globalState.bloomIntensity);\n    indicator.setFpsLimitEnabled(globalState.enableFpsLimit);\n    indicator.setMSAAEnabled(globalState.enableMSAA);\n    indicator.setFpsLimit(globalState.fpsLimit);\n    indicator.setRayMovementSpeed(globalState.raySpeed);\n    indicator.setTextureSizeModifier(globalState.renderingResolution);\n    indicator.setRotationSpeed(globalState.rotationSpeed);\n    indicator.setColors(globalState.segmentColors);\n    indicator.setSegmentCounts(globalState.segmentCounts);\n    indicator.setSegmentAdjustmentStepDuration(globalState.segmentAdjustmentStepDuration);\n    // Start the rendering\n    indicator.enterRenderingLoop();\n    // Also, hook up an event listener\n    const obs = new ResizeObserver(() => { indicator.onResize(); });\n    obs.observe(canvas);\n}\n// Runs a simple simulation to automate the segments.\nfunction simulationStep(indicator) {\n    if (!globalState.simulation) {\n        return;\n    }\n    const rand = Math.random();\n    if (rand < 0.3) {\n        globalState.segmentCounts[0]++;\n    }\n    else if (rand < 0.6) {\n        globalState.segmentCounts[1]++;\n    }\n    else if (rand > 0.9) {\n        // 10% chance of resetting the entire state\n        globalState.segmentCounts[0] = 1;\n        globalState.segmentCounts[1] = 0;\n        globalState.segmentCounts[2] = 0;\n        globalState.segmentCounts[3] = 0;\n    }\n    else {\n        globalState.segmentCounts[2]++;\n    }\n    indicator.setSegmentCounts(globalState.segmentCounts);\n    for (let i = 0; i < 4; i++) {\n        document.querySelector(`#segment-${i + 1}-count`).value = String(globalState.segmentCounts[i]);\n    }\n}\n// Provide the constructor to the Window object so that it can be instantiated.\nwindow.setupIrisIndicator = setupIrisIndicator;\n\n\n//# sourceURL=webpack://corona-webgl/./src/index.ts?\n}");

/***/ },

/***/ "./src/iris-indicator.ts"
/*!*******************************!*\
  !*** ./src/iris-indicator.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IrisIndicator: () => (/* binding */ IrisIndicator)\n/* harmony export */ });\n/* harmony import */ var _webgl_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-engine */ \"./src/webgl-engine.ts\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"./src/index.ts\");\n/* harmony import */ var _util_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/math */ \"./src/util/math.ts\");\n\n\n\n/**\n * This class creates and maintains an entire Iris indicator.\n */\nclass IrisIndicator {\n    /**\n     * Creates a new iris indicator, to be rendered within the WebGL context of a\n     * canvas.\n     *\n     * @param   {WebGL2RenderingContext}  gl  The context\n     */\n    constructor(gl) {\n        this.engine = new _webgl_engine__WEBPACK_IMPORTED_MODULE_0__.WebGLEngine(gl);\n        this.resizeOnNextDraw = false;\n        // FPS setup\n        this.fpsLimitEnabled = true;\n        this.fpsLimit = Math.floor(1000 / 30);\n        this.frameTimings = [];\n        // Animation setup\n        this.segmentAdjustmentAnimationStepDuration = 100;\n        this.msPerRotation = 240000;\n        this.rayMovementSpeed = 5000;\n        // Segment setup\n        this.colormap = {\n            blue: [0.2, 0.5, 1.0, 1.0],\n            red: [1.0, 0.3, 0.3, 1.0],\n            green: [0.3, 1.0, 0.3, 1.0],\n            yellow: [1.0, 1.0, 0.3, 1.0],\n            purple: [1.0, 0.3, 1.0, 1.0]\n        };\n        this.segmentCounts = [0, 0, 0, 0];\n        this.segmentRatiosTarget = [0, 0, 0, 0];\n        this.segmentRatiosCurrent = [0, 0, 0, 0];\n        this.segmentColors = [\n            this.colormap.red, this.colormap.green,\n            this.colormap.blue, this.colormap.purple\n        ];\n        // Ray setup\n        this.autoRayAdjustmentFactor = 5;\n        this.nRays = this.calculateOptimalRayCount();\n        this.autoAdjustRays = true;\n        this.rays = [];\n        this.generateRays();\n        this.setSegments();\n        this.timestamp = Date.now();\n    }\n    /// SEGMENT SETTERS\n    /**\n     * Sets the colors to be used in the corona indicator. Choose one for each\n     * from the provided colors.\n     *\n     * @param  {Vec4<BuiltinColor>}  colors  The colors to use for each segment\n     */\n    setColors(colors) {\n        for (let i = 0; i < this.segmentColors.length; i++) {\n            switch (colors[i]) {\n                case 'blue':\n                    this.segmentColors[i] = this.colormap.blue;\n                    break;\n                case 'green':\n                    this.segmentColors[i] = this.colormap.green;\n                    break;\n                case 'purple':\n                    this.segmentColors[i] = this.colormap.purple;\n                    break;\n                case 'red':\n                    this.segmentColors[i] = this.colormap.red;\n                    break;\n                case 'yellow':\n                    this.segmentColors[i] = this.colormap.yellow;\n            }\n        }\n        this.setSegments();\n    }\n    /**\n     * Sets the segment adjustment step duration in Milliseconds. What this means\n     * is that each `duration`ms, the segments will be moved closer towards their\n     * target size. Note, however, that the actual duration is longer, since the\n     * step sizes will be smaller to produce an easing effect.\n     *\n     * @param   {number}  duration  The duration in milliseconds. Default is 200.\n     */\n    setSegmentAdjustmentStepDuration(duration) {\n        this.segmentAdjustmentAnimationStepDuration = duration;\n    }\n    /**\n     * Set the current element counts to be displayed in the corona indicator.\n     *\n     * @param  {number[]}  counts  The amount for each segment. Must be absolute.\n     */\n    setSegmentCounts(counts) {\n        let sum = 0;\n        for (let i = 0; i < this.segmentCounts.length; i++) {\n            // @ts-expect-error TS is really unhappy for dynamic addressing\n            this.segmentCounts[i] = counts[i];\n            // @ts-expect-error TS is really unhappy for dynamic addressing\n            sum += counts[i];\n        }\n        if (sum === 0) {\n            this.segmentRatiosTarget = [0, 0, 0, 0];\n        }\n        else {\n            // @ts-expect-error TS cannot determine that Vec4 is indeed four numbers.\n            this.segmentRatiosTarget = this.segmentCounts.map(c => c / sum);\n        }\n        this.setSegments();\n    }\n    // Writes the current segment information into the renderer\n    setSegments() {\n        // @ts-expect-error We literally fill it in the line below\n        const segs = [];\n        for (let i = 0; i < this.segmentCounts.length; i++) {\n            // @ts-expect-error Funny how TS thinks anything dynamically could be\n            // undefined. I mean, it's not entirely wrong.\n            segs.push({ color: this.segmentColors[i], ratio: this.segmentRatiosCurrent[i] });\n        }\n        this.engine.setSegments(segs);\n    }\n    /**\n     * Specify the number of rays to be drawn. NOTE: This disables the auto-\n     * adjustment of the number of rays on resizing the canvas.\n     *\n     * @param   {number}  count  The number of rays to draw.\n     */\n    setRayCount(count) {\n        this.autoAdjustRays = false;\n        this.nRays = count;\n    }\n    /// ANIMATION SETTERS\n    /**\n     * Determines how fast the corona will rotate around the origin. Provide the\n     * number of seconds for one full rotation. Default is 45 seconds. We\n     * generally do not recommend a fast rate here.\n     *\n     * @param   {number}  seconds  The number of seconds per full rotation\n     */\n    setRotationSpeed(seconds) {\n        this.msPerRotation = seconds * 1000;\n    }\n    /**\n     * Sets the ray movement speed in seconds. Each ray has an \"inner\" and an\n     * \"outer\" radius, and it will oscillate between these two to provide more\n     * movement to the animation. With this function, you can determine how many\n     * seconds it will take for each ray to move from its minimum to its maximum\n     * radius (and vice versa). The default is 5.\n     *\n     * @param   {number}  seconds  The number of seconds for one movement.\n     */\n    setRayMovementSpeed(seconds) {\n        this.rayMovementSpeed = seconds * 1000;\n    }\n    /**\n     * This will set the renderer to automatically calculate the amount of rays to\n     * be draawn.\n     */\n    enableAutomaticRayAdjustment() {\n        this.autoAdjustRays = true;\n        this.nRays = this.calculateOptimalRayCount();\n        this.generateRays();\n    }\n    /// EFFECTS SETTERS\n    /**\n     * Enables or disables the bloom on the renderer.\n     *\n     * @param   {boolean}  enabled  Whether bloom is enabled\n     */\n    setBloomEnabled(enabled) {\n        this.engine.setBloomEnabled(enabled);\n    }\n    /**\n     * Sets the intensity of the bloom effect\n     *\n     * @param  {1|2|4|8}  intensity  The wanted intensity\n     */\n    setBloomIntensity(intensity) {\n        this.engine.setBloomIntensity(intensity);\n    }\n    /**\n     * Enables or disables MSAA.\n     *\n     * @param   {boolean}  enabled  Whether MSAA is enabled\n     */\n    setMSAAEnabled(enabled) {\n        this.engine.setMSAAEnabled(enabled);\n    }\n    /**\n     * Sets the rendering resolution/texture size modifier. The higher, the more\n     * resource heavy, but also the sharper the result, especially with MSAA on.\n     *\n     * @param   {number}  mod  The modifier\n     */\n    setTextureSizeModifier(mod) {\n        this.engine.setTextureSizeModifier(mod);\n        this.onResize(); // We need to recalculate the textures\n    }\n    /// FPS SETTERS\n    /**\n     * Enables or disables the FPS limiter\n     *\n     * @param   {boolean}  enabled  Whether the FPS limiter should be enabled\n     */\n    setFpsLimitEnabled(enabled) {\n        this.fpsLimitEnabled = enabled;\n    }\n    /**\n     * Sets the FPS limit (common values are 30 or 60). Default is 30.\n     *\n     * @param   {number}  fpsLimit  The new FPS limit.\n     */\n    setFpsLimit(fpsLimit) {\n        this.fpsLimit = Math.floor(1000 / fpsLimit); // Convert to MS per frame\n    }\n    /**\n     * Returns the current average frames per second, sampled over the last 120 fps.\n     *\n     * @return  {number}  The average Fps\n     */\n    getCurrentFps() {\n        const avgFps = this.frameTimings.length > 0\n            ? this.frameTimings.reduce((p, c) => p + c, 0) / this.frameTimings.length\n            : 0;\n        return avgFps;\n    }\n    /// RENDERING LOOP CONTROLS\n    /**\n     * Callback function used to indicate to the indicator that the canvas size\n     * has changed and the renderer should re-calculate various numbers.\n     */\n    onResize() {\n        this.resizeOnNextDraw = true;\n    }\n    /**\n     * Main function: Call this to start rendering to the canvas.\n     */\n    enterRenderingLoop() {\n        requestAnimationFrame(ts => this.loop(ts));\n    }\n    /**\n     * Main loop executor\n     */\n    loop(timestamp) {\n        const deltaTime = this.previousTimestamp === undefined ? 0 : timestamp - this.previousTimestamp;\n        if (this.fpsLimitEnabled) {\n            if (deltaTime > 0 && deltaTime < this.fpsLimit) {\n                return requestAnimationFrame(ts => this.loop(ts));\n            }\n        }\n        // We must update the time HERE, because otherwise our fps counts and\n        // limiting would be off.\n        this.previousTimestamp = timestamp;\n        this.frameTimings.push(deltaTime > 0 ? 1000 / deltaTime : 0);\n        while (this.frameTimings.length > 120) {\n            this.frameTimings.shift();\n        }\n        this.drawFrame();\n        requestAnimationFrame(ts => this.loop(ts));\n    }\n    /**\n     * Calculates the optimal amount of rays based on the current canvas size. The\n     * various calculations have been empirically determined.\n     *\n     * @return  {number}  The number of rays that would look good at the current\n     *                    resolution.\n     */\n    calculateOptimalRayCount() {\n        const { cWidth, cHeight } = this.engine.textureSize();\n        const smallestEdge = Math.min(cWidth, cHeight);\n        const wantedRayCount = Math.round(smallestEdge / this.autoRayAdjustmentFactor);\n        return Math.max(wantedRayCount, 16);\n    }\n    /**\n     * This routine actually calculates everything whenever a resize command is\n     * issued.\n     */\n    doResizeCalculation() {\n        this.resizeOnNextDraw = false;\n        this.engine.onResize();\n        if (this.autoAdjustRays) {\n            this.nRays = this.calculateOptimalRayCount();\n        }\n        this.generateRays();\n    }\n    /**\n     * (Re-)generate the rays to be displayed.\n     */\n    generateRays() {\n        // We want to display an iris. For that, we need pure triangles.\n        // We compute them here, and then perform only a bit of adjustment during\n        // the rendering.\n        this.rays = [];\n        const { cWidth, cHeight } = this.engine.textureSize();\n        // Draw a clock-like structure\n        const canvasDiameter = Math.min(cWidth, cHeight);\n        const canvasRadius = canvasDiameter / 2;\n        const outerRadius = 1.0 * canvasRadius;\n        const innerRadius = 0.3 * canvasRadius;\n        const minVaryRadius = 0.6 * canvasRadius;\n        // Each \"tick\" will be one radian on the unit circle. We want the tris to\n        // overlap at their base so that they appear close together at their actual\n        // inner start radius. We have three rads per tri (two bottom, one middle\n        // top). Furthermore, we have to increase the tick size based on the inner\n        // radius (so that the tris touch there). Note that the 3 is an arbitrary\n        // number. It is fine if the tris overlap more. The importance is that\n        // visually they form a ring at the center.\n        const overlapFactor = 3; // Should be > 1\n        const widthInRadians = ((2 * Math.PI) / (this.nRays * 3)) * overlapFactor;\n        for (let i = 0; i < this.nRays; i++) {\n            // Position (in % of a circle)\n            const pos = i / this.nRays;\n            // Determine the center of the ray in radians\n            const centerInRad = pos * 2 * Math.PI;\n            // Vary the radii of each ray so that we have some movement.\n            const RADIUS_VARIATION = 0.1;\n            const rMin = minVaryRadius + Math.random() * RADIUS_VARIATION * canvasRadius;\n            const rMax = outerRadius - Math.random() * RADIUS_VARIATION * canvasRadius;\n            const startRadius = minVaryRadius + (rMax - rMin) * Math.random();\n            this.rays.push({\n                // Save some state to make regeneration of the coords easier\n                radians: centerInRad, width: widthInRadians,\n                // Save some state into the tri so that we can change the size dynamically\n                radius: { inner: innerRadius, min: rMin, max: rMax, current: startRadius, inc: Math.random() > 0.5 }\n            });\n        }\n    }\n    /**\n     * This routine actually draws a frame by performing any update calculations\n     * and perusing the WebGL rendering engine to draw the data onto the screen.\n     */\n    drawFrame() {\n        // Movement only depends on actually passed time.\n        const now = Date.now();\n        const deltaMs = now - this.timestamp;\n        this.timestamp = now;\n        // If we have a signal to resize, we need to do so now before drawing again.\n        if (this.resizeOnNextDraw) {\n            this.doResizeCalculation();\n        }\n        // Determine by how much we should adjust the target ratios for the\n        // segments.\n        const step = deltaMs / this.segmentAdjustmentAnimationStepDuration;\n        // SEGMENT ROTATION (time-dependent)\n        let hasRatioChanged = false;\n        for (let i = 0; i < ___WEBPACK_IMPORTED_MODULE_1__.MAX_SUPPORTED_SEGMENTS; i++) {\n            const cur = this.segmentRatiosCurrent[i];\n            const tar = this.segmentRatiosTarget[i];\n            if (cur === tar) {\n                continue;\n            }\n            hasRatioChanged = true;\n            // Adjust current closer to target\n            const direction = cur > tar ? -1 : 1;\n            const difference = Math.abs(tar - cur); // absolute difference\n            // To avoid infinite segment updates (and thus unnecessary updates), we\n            // \"snap\" to the target ratio if the difference becomes very small.\n            if (difference < 10e-4) {\n                this.segmentRatiosCurrent[i] = tar;\n            }\n            else {\n                // By moving by just a fraction of the remaining difference, we\n                // effectively produce an easing animation that starts very fast and\n                // slows down as the difference to the target is reduced.\n                this.segmentRatiosCurrent[i] += direction * step * difference;\n            }\n        }\n        if (hasRatioChanged) {\n            this.setSegments();\n        }\n        // MODIFY RAYS\n        // Speed says how quickly each ray moves between its minimum and maximum radius.\n        const speed = deltaMs / this.rayMovementSpeed;\n        for (const ray of this.rays) {\n            const { min, max } = ray.radius;\n            let { current, inc } = ray.radius;\n            const increment = (max - min) * speed;\n            current = inc ? current + increment : current - increment;\n            if (current <= min) {\n                current = min;\n                inc = true;\n            }\n            else if (current >= max) {\n                current = max;\n                inc = false;\n            }\n            ray.radius = Object.assign(Object.assign({}, ray.radius), { current, inc });\n        }\n        const data = this.rays\n            .map(({ radians, width, radius }) => {\n            return (0,_util_math__WEBPACK_IMPORTED_MODULE_2__.coordsForRay)(radians, width, radius.inner, radius.current);\n        })\n            .flatMap(coords => coords);\n        // All elements / 2 (coordinates) / number of elements\n        // --> One component is two numbers (coordinates)\n        const componentsPerTri = 3;\n        const triangleData = new Float32Array(data);\n        const nComponents = componentsPerTri * this.rays.length;\n        // ROTATION MATRIX PREPARATION (time-dependent)\n        const rot = now % this.msPerRotation / this.msPerRotation; // Clamp between 0 and 1\n        const moveByRadians = -rot * (2 * Math.PI); // Move \"backwards\" (=clockwise)\n        // TRANSLATION MATRIX PREPARATION\n        const { cWidth, cHeight } = this.engine.textureSize();\n        const originX = cWidth / 2;\n        const originY = cHeight / 2;\n        const mat = (0,_util_math__WEBPACK_IMPORTED_MODULE_2__.mat3mul)((0,_util_math__WEBPACK_IMPORTED_MODULE_2__.translationMatrix)(originX, originY), (0,_util_math__WEBPACK_IMPORTED_MODULE_2__.rotationMatrix)(moveByRadians));\n        // Provide the calculated data to the engine to actually draw everything.\n        this.engine.draw(triangleData, nComponents, mat);\n    }\n}\n\n\n//# sourceURL=webpack://corona-webgl/./src/iris-indicator.ts?\n}");

/***/ },

/***/ "./src/shaders/fragment_shader.glsl"
/*!******************************************!*\
  !*** ./src/shaders/fragment_shader.glsl ***!
  \******************************************/
(module) {

eval("{module.exports = \"#version 300 es // Use WebGL2/ES 3.0\\n\\n// Fragment shader: Specifies colors for each pixel.\\n// Good resource, too: https://learnwebgl.brown37.net/12_shader_language/glsl_builtin_functions.html\\n// Cheat sheet: https://learnwebgl.brown37.net/12_shader_language/documents/webgl-reference-card-1_0.pdf\\n// Define a precision\\nprecision highp float;\\n\\n// Enum that must be defined the same way in the WebGL code and the shaders.\\n// This defines what transformation the fragment shader will apply to the color\\n// values. NOTE that mostly this will be implemented into six different shaders,\\n// but I wanted to keep only a single WebGL program to reduce complexity.\\nfloat FRAGMENT_PASS_PASSTHROUGH = 0.0;\\nfloat FRAGMENT_PASS_NORMAL = 1.0;\\nfloat FRAGMENT_PASS_BLUR = 2.0;\\nfloat FRAGMENT_PASS_COMPOSITE = 3.0;\\nfloat FRAGMENT_PASS_TONEMAP = 4.0;\\nfloat FRAGMENT_PASS_BRIGHTNESS = 5.0;\\n\\n// Coming from the vertex shader\\nin vec2 v_texcoord;\\nin float v_pass; // Which pass are we in currently?\\n\\n// Produced by the fragment shader. (The fragment shader can write to multiple\\n// color attachments on framebuffers using the location parameter.)\\nlayout (location = 0) out vec4 fragColor;\\n\\n// Courtesy of https://learnopengl.com/Advanced-Lighting/Bloom\\nuniform bool u_blur_horizontal; // If true, blur horizontally\\nfloat blur_weight[7] = float[7] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216, 0.007, 0.002); // Weights for blurring\\nconst int repeats = 7; // How many of the weights should we use?\\n\\nuniform sampler2D u_texture; // Main texture\\nuniform sampler2D u_blurTexture; // Blur texture\\n\\n// This is a color that is set during inactivity. It should also be very bright\\n// but have no color.\\nvec4 INACTIVE_COLOR = vec4(1.0); // vec4(10.0, 10.0, 10.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433;\\nconst float MAX_RADIANS = PI * 2.0;\\n\\n// Describes one segment of the indicator circle. All ratios must add up to 1\\nstruct Segment {\\n  float ratio;\\n  vec4 color;\\n};\\n\\n// We allow up to four segments. These can define colors and ratios.\\nuniform Segment u_segments[4];\\n\\n// Specifies the blend ratio. We pass it as a uniform to reduce the amount of\\n// recomputation, since this is only dependent on the minimum ratio in the\\n// Segments. Deferring this work to JavaScript cuts on GPU time.\\nuniform float u_blendRatio;\\n\\nfloat luminance (vec3 c) {\\n  // Magic numbers used to calculate luminance (copied from somewhere on the internet)\\n  return dot(c, vec3(0.2126, 0.7152, 0.0722));\\n}\\n\\nvec3 reinhard_jodie_tonemap (vec3 c) {\\n    float l = luminance(c);\\n    vec3 tc = c / (c + 1.0);\\n    return mix(c / (l + 1.0), tc, tc);\\n}\\n\\n// cf.: https://64.github.io/tonemapping/\\nvec3 aces_approx_tonemap(vec3 v) {\\n    v *= 0.6;\\n    float a = 2.51;\\n    float b = 0.03;\\n    float c = 2.43;\\n    float d = 0.59;\\n    float e = 0.14;\\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\\n}\\n\\nvec4 compute_color () {\\n  // Compute the correct color for the pixel at this position.\\n  // NOTE: We MUST convert the coords to clip space in the vertex shader and\\n  // then back here for the rasterizer to work which will look at the variable\\n  // in between! Even though it appears like double-work, comparing what the\\n  // vertex shader does, and what we have to do here.\\n  vec2 coords = (v_texcoord.xy - 0.5) * 2.0 * vec2(-1, 1);\\n  // NOTE: `atan` works like the `atan2` we know from, e.g., C or JS, not like\\n  // `atan`.\\n  float rad = atan(coords.y, coords.x) + PI;\\n\\n  float radThreshold = MAX_RADIANS * u_blendRatio;\\n\\n  float segmentStart = 0.0; // In rads\\n  float segmentEnd = 0.0; // In rads\\n  vec4 prevColor = INACTIVE_COLOR;\\n  // Preset with the color of the last non-empty segment\\n  for (int i = u_segments.length() - 1; i >= 0; i--) {\\n    if (u_segments[i].ratio > 0.0) {\\n      prevColor = u_segments[i].color;\\n      break;\\n    }\\n  }\\n\\n  for (int i = 0; i < u_segments.length(); i++) {\\n    if (u_segments[i].ratio == 0.0) {\\n      continue; // Skip this segment\\n    }\\n\\n    vec4 currentColor = u_segments[i].color;\\n    segmentEnd = segmentStart + u_segments[i].ratio * MAX_RADIANS;\\n\\n    if (rad >= segmentStart && rad <= segmentStart + radThreshold) {\\n      // Pixel is in the blend-area between prev color and current color\\n      // Mix ratio must range between 0.5 (mix between prev and cur) and 1.0\\n      // (only cur).\\n      float blendStart = segmentStart - radThreshold;\\n      float blendEnd = segmentStart + radThreshold;\\n      // Avoid division by zero at the start of our calculations\\n      return mix(prevColor, currentColor, (rad - blendStart + 1.0) / (blendEnd - blendStart + 1.0));\\n    } else if (rad > segmentStart + radThreshold && rad <= segmentEnd - radThreshold) {\\n      // Pixel is in the solid current color area\\n      return currentColor;\\n    } else if (rad > segmentEnd - radThreshold && rad <= segmentEnd) {\\n      // Pixel is in the blend-area between current color and next color\\n      // Find the next available color (read: which is not a ratio of 0)\\n      vec4 nextColor = INACTIVE_COLOR;\\n      int next = i == u_segments.length() - 1 ? 0 : i + 1;\\n      Segment nextSegment = u_segments[next];\\n      for (int j = 0; j < u_segments.length(); j++) {\\n        if (nextSegment.ratio > 0.0) {\\n          nextColor = nextSegment.color;\\n          break;\\n        }\\n\\n        next++;\\n\\n        if (next >= u_segments.length() - 1) {\\n          next = 0;\\n        }\\n\\n        nextSegment = u_segments[next];\\n      }\\n\\n      float blendStart = segmentEnd - radThreshold;\\n      float blendEnd = segmentEnd + radThreshold;\\n      return mix(currentColor, nextColor, (rad - blendStart) / (blendEnd - blendStart));\\n    }\\n\\n    // Pixel is not in this color segment -> check next iteration\\n    segmentStart = segmentEnd;\\n    prevColor = u_segments[i].color;\\n  }\\n\\n  // We couldn't associate the current pixel with any segment. This usually only\\n  // happens when the ratios do not sum up to 1.0. Return the inactive color..\\n  return INACTIVE_COLOR;\\n}\\n\\n// Courtesy of https://learnopengl.com/Advanced-Lighting/Bloom\\nvec4 blur () {\\n  vec2 texel = vec2(1.0, 1.0) / vec2(textureSize(u_texture, 0));\\n  vec4 result = texture(u_texture, v_texcoord) * blur_weight[0];\\n  if (u_blur_horizontal) {\\n    for (int i = 1; i < repeats; i++) {\\n      result += texture(u_texture, v_texcoord + texel * vec2(i, 0.0)) * blur_weight[i];\\n      result += texture(u_texture, v_texcoord - texel * vec2(i, 0.0)) * blur_weight[i];\\n    }\\n  } else {\\n    for (int i = 1; i < repeats; i++) {\\n      result += texture(u_texture, v_texcoord + texel * vec2(0.0, i)) * blur_weight[i];\\n      result += texture(u_texture, v_texcoord - texel * vec2(0.0, i)) * blur_weight[i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nvec3 tonemap (vec3 color) {\\n  // Exposure setting\\n  const float exposure = 0.5;\\n  color = vec3(1.0) - exp(-color * exposure);\\n  // Gamma correction\\n  const float gamma = 0.8;\\n  color = pow(color, vec3(1.0 / gamma));\\n  return color;\\n}\\n\\nvoid main() {\\n  if (v_pass == FRAGMENT_PASS_PASSTHROUGH) {\\n    // Pass-through: only copies the texture information\\n    fragColor = texture(u_texture, v_texcoord);\\n  } else if (v_pass == FRAGMENT_PASS_NORMAL) {\\n    // Render-pass: This renders the rays, which means we need to calculate the\\n    // colors for each ray based on the circle information provided in the\\n    // segments.\\n    fragColor = compute_color();\\n  } else if (v_pass == FRAGMENT_PASS_BRIGHTNESS) {\\n    // Brightness pass: Should return only very bright pixels; used for the\\n    // bloom filter.\\n    fragColor = texture(u_texture, v_texcoord);\\n    float l = luminance(fragColor.rgb);\\n    fragColor = l > 1.0 ? fragColor : vec4(0.0, 0.0, 0.0, 0.0);\\n  } else if (v_pass == FRAGMENT_PASS_BLUR) {\\n    // Blur-pass: This receives a texture (the brightness texture from the\\n    // brightness pass), and should apply blur to it. It does so alternatingly\\n    // horizontally and vertically.\\n    fragColor = blur();\\n  } else if (v_pass == FRAGMENT_PASS_COMPOSITE) {\\n    // Compositing pass: This receives two textures, a blurred one and the\\n    // original, and it should merge the two. It also applies some tone mapping.\\n    vec4 originalColor = texture(u_texture, v_texcoord);\\n    vec4 blurColor = texture(u_blurTexture, v_texcoord);\\n    fragColor = originalColor + blurColor;\\n  } else if (v_pass == FRAGMENT_PASS_TONEMAP) {\\n    float alpha = texture(u_texture, v_texcoord).a;\\n    vec3 result_color = texture(u_texture, v_texcoord).rgb;\\n    // const float exposure = 0.5;\\n    const float exposure = 0.5;\\n    result_color = vec3(1.0) - exp(-result_color.rgb * exposure);\\n    // Gamma correction\\n    const float gamma = 0.8;\\n    result_color = pow(result_color.rgb, vec3(1.0 / gamma));\\n    fragColor = vec4(result_color, alpha);\\n  }\\n}\\n\";\n\n//# sourceURL=webpack://corona-webgl/./src/shaders/fragment_shader.glsl?\n}");

/***/ },

/***/ "./src/shaders/vertex_shader.glsl"
/*!****************************************!*\
  !*** ./src/shaders/vertex_shader.glsl ***!
  \****************************************/
(module) {

eval("{module.exports = \"#version 300 es // Use WebGL2/ES 3.0\\n\\n// Vertex shaders: Compute positions (from 3d -> clip plane)\\n\\n// Enum that must be defined the same way in the WebGL code and the shaders\\nfloat FRAGMENT_PASS_PASSTHROUGH = 0.0;\\nfloat FRAGMENT_PASS_NORMAL = 1.0;\\nfloat FRAGMENT_PASS_BLUR = 2.0;\\nfloat FRAGMENT_PASS_COMPOSITE = 3.0;\\nfloat FRAGMENT_PASS_TONEMAP = 4.0;\\nfloat FRAGMENT_PASS_BRIGHTNESS = 5.0;\\n\\n// \\\"in\\\" declares something that receives data from JS\\nin vec2 a_position; // NOTE: 2d because we work in x/y pixels\\n\\nuniform vec2 u_resolution; // The canvas resolution (\\\"uniform\\\" = remains the same for each call of the shader)\\nuniform mat3 u_matrix; // Transformation matrix, to be applied to each position\\nuniform float u_pass; // Which pass are we in currently?\\n\\n// Pass the following to the fragment shader\\nout vec2 v_texcoord;\\nout float v_pass; // We must pass the uniform from here.\\n\\n// This function will be executed by the GPU\\nvoid main() {\\n  // First, apply our transformation (remember mat3 is xyz, but we don't use z)\\n  // NOTE: We only perform the transformation in the first render pass. After\\n  // that we are only doing post-processing, so we can essentially just forward\\n  // the untransformed position.\\n  vec2 transformed = u_pass == FRAGMENT_PASS_NORMAL\\n    ? (u_matrix * vec3(a_position, 1)).xy\\n    : a_position;\\n\\n  v_pass = u_pass;\\n\\n  // Convert pixel into clip space (aka -1 till +1)\\n  // We use a standard z transform for that (normalize->scale->center)\\n  vec2 normalized = transformed / u_resolution; // Abs -> 0; +1\\n  vec2 scaled = normalized * 2.0; // 0; +1 -> 0; +2\\n  vec2 centered = scaled - 1.0; // 0; +2 -> -1; +1\\n  vec2 clipSpacePx = centered * vec2(1, -1); // Flip y-coordinates\\n\\n  // gl_Position is a special variable that \\\"returns\\\" the computed position.\\n  // We compute that one in this shader.\\n  // We use the clip space x/y variable, provide z = 0 and w = 1 because we\\n  // only want 2d.\\n  gl_Position = vec4(clipSpacePx, 0, 1);\\n  // The position is the same as the one for the position on the texture\\n  // However, we must convert from clip space to UV space (0; 1 from bottom-left)\\n  v_texcoord = clipSpacePx * 0.5 + 0.5;\\n}\\n\";\n\n//# sourceURL=webpack://corona-webgl/./src/shaders/vertex_shader.glsl?\n}");

/***/ },

/***/ "./src/ui.ts"
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupUI: () => (/* binding */ setupUI)\n/* harmony export */ });\n/**\n * Utility function to make hooking up UI inputs easier.\n *\n * @param   {string}            id            The ID of the input element\n * @param   {any}               defaultValue  The default value for the input element\n * @param   {HTMLInputElement}  onChange      A callback to be called on change\n */\nfunction setupInputElement(id, defaultValue, onChange) {\n    const elem = document.querySelector(`#${id}`);\n    if (elem === null) {\n        return;\n    }\n    if (typeof defaultValue === 'boolean') {\n        elem.checked = defaultValue;\n    }\n    else if (typeof defaultValue === 'string') {\n        elem.value = defaultValue;\n    }\n    else if (typeof defaultValue === 'number') {\n        elem.value = String(defaultValue);\n    }\n    elem.addEventListener('change', () => onChange(elem));\n}\n/**\n * Sets up a basic UI for the demo page.\n *\n * @param  {IrisIndicator}  iris   The indicator to apply changes to\n * @param  {GLOBAL_STATE}   state  The initial state\n */\nfunction setupUI(iris, state) {\n    setupInputElement('fps-limit', state.enableFpsLimit, fpsLimiter => {\n        state.enableFpsLimit = fpsLimiter.checked;\n        iris.setFpsLimitEnabled(fpsLimiter.checked);\n    });\n    setupInputElement('fps-limit-count', state.fpsLimit, fpsLimit => {\n        state.fpsLimit = parseInt(fpsLimit.value);\n        iris.setFpsLimit(state.fpsLimit);\n    });\n    setupInputElement('rotation-speed', state.rotationSpeed, rotationSpeed => {\n        state.rotationSpeed = parseInt(rotationSpeed.value);\n        iris.setRotationSpeed(state.rotationSpeed);\n    });\n    setupInputElement('ray-speed', state.raySpeed, raySpeed => {\n        state.raySpeed = parseFloat(raySpeed.value);\n        iris.setRayMovementSpeed(state.raySpeed);\n    });\n    setupInputElement('segment-adjustment-step-duration', state.segmentAdjustmentStepDuration, adj => {\n        state.segmentAdjustmentStepDuration = parseInt(adj.value);\n        iris.setSegmentAdjustmentStepDuration(state.segmentAdjustmentStepDuration);\n    });\n    setupInputElement('enable-bloom', state.bloomEnabled, bloom => {\n        state.bloomEnabled = bloom.checked;\n        iris.setBloomEnabled(bloom.checked);\n    });\n    setupInputElement('bloom-intensity', state.bloomIntensity, bloom => {\n        state.bloomIntensity = parseInt(bloom.value);\n        iris.setBloomIntensity(state.bloomIntensity);\n    });\n    setupInputElement('enable-msaa', state.enableMSAA, msaa => {\n        state.enableMSAA = msaa.checked;\n        iris.setMSAAEnabled(state.enableMSAA);\n    });\n    setupInputElement('rendering-resolution', Math.min(window.devicePixelRatio, 2), renderingResolution => {\n        iris.setTextureSizeModifier(parseInt(renderingResolution.value));\n    });\n    setupInputElement('enable-simulation', state.simulation, simulation => {\n        state.simulation = simulation.checked;\n    });\n    for (let i = 0; i < 4; i++) {\n        setupInputElement(`segment-${i + 1}-color`, state.segmentColors[i], col => {\n            state.segmentColors[i] = col.value;\n            iris.setColors(state.segmentColors);\n        });\n        setupInputElement(`segment-${i + 1}-count`, state.segmentCounts[i], cnt => {\n            state.segmentCounts[i] = parseInt(cnt.value);\n            iris.setSegmentCounts(state.segmentCounts);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://corona-webgl/./src/ui.ts?\n}");

/***/ },

/***/ "./src/util/math.ts"
/*!**************************!*\
  !*** ./src/util/math.ts ***!
  \**************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coordsForRay: () => (/* binding */ coordsForRay),\n/* harmony export */   mat3mul: () => (/* binding */ mat3mul),\n/* harmony export */   rotationMatrix: () => (/* binding */ rotationMatrix),\n/* harmony export */   translationMatrix: () => (/* binding */ translationMatrix)\n/* harmony export */ });\n/**\n * Calculates a triangle based on some information on a ray.\n *\n * @param  {number}  radians      The circule position of the ray\n * @param  {number}  width        The width of the ray at its base (in radians/2)\n * @param  {number}  innerRadius  The inner radius of the ray\n * @param  {number}  outerRadius  The outer radius of the ray\n */\nfunction coordsForRay(radians, width, innerRadius, outerRadius) {\n    const [rad1, rad2, rad3] = [radians - width, radians, radians + width];\n    // Each tri needs three coordinates\n    const [x1, y1, x2, y2, x3, y3] = [\n        // NOTE: These coordinates need to go around the tri in order!\n        // NOTE 2: We do not translate them here away from the origin, because that's\n        // what our translation matrix does in the render loop\n        Math.cos(rad1) * innerRadius, Math.sin(rad1) * innerRadius,\n        Math.cos(rad2) * outerRadius, Math.sin(rad2) * outerRadius,\n        Math.cos(rad3) * innerRadius, Math.sin(rad3) * innerRadius\n    ];\n    return [x1, y1, x2, y2, x3, y3];\n}\n/**\n * Takes a translation coordinate (x/y) and creates a 3D-matrix which, when\n * multiplied with a position vector, will translate that vector by this amount.\n * Courtesy of WebGL fundamentals.\n *\n * @param   {number}  tx  The x-axis translation\n * @param   {number}  ty  The y-axis translation\n * @returns {Mat3}        The translation matrix\n */\nfunction translationMatrix(tx, ty) {\n    return [\n        1, 0, 0,\n        0, 1, 0,\n        tx, ty, 1\n    ];\n}\n/**\n * Takes a rotation in radians and produces a matrix that, when multiplied with\n * a position vector, will rotate this vector by this amount. Courtesy of WebGL\n * fundamentals.\n *\n * @param   {number}  rad  The angles to rotate around\n * @returns {Mat3}         The rotation matrix\n */\nfunction rotationMatrix(rad) {\n    const c = Math.cos(rad);\n    const s = Math.sin(rad);\n    return [\n        c, -s, 0,\n        s, c, 0,\n        0, 0, 1\n    ];\n}\n/**\n * Takes two matrices and multiplies them. Courtesy of WebGL fundamentals.\n *\n * @param   {Mat3}  mat1  Matrix one\n * @param   {Mat3}  mat2  Matrix two\n * @returns {Mat3}        The resulting matrix\n */\nfunction mat3mul(mat1, mat2) {\n    // Copied and adapted from the webglfundamentals example because that's just a\n    // lot of boilerplate code. Thanks to whoever coded this up!\n    const [a00, a01, a02] = [mat1[0 * 3 + 0], mat1[0 * 3 + 1], mat1[0 * 3 + 2]];\n    const [a10, a11, a12] = [mat1[1 * 3 + 0], mat1[1 * 3 + 1], mat1[1 * 3 + 2]];\n    const [a20, a21, a22] = [mat1[2 * 3 + 0], mat1[2 * 3 + 1], mat1[2 * 3 + 2]];\n    const [b00, b01, b02] = [mat2[0 * 3 + 0], mat2[0 * 3 + 1], mat2[0 * 3 + 2]];\n    const [b10, b11, b12] = [mat2[1 * 3 + 0], mat2[1 * 3 + 1], mat2[1 * 3 + 2]];\n    const [b20, b21, b22] = [mat2[2 * 3 + 0], mat2[2 * 3 + 1], mat2[2 * 3 + 2]];\n    return [\n        b00 * a00 + b01 * a10 + b02 * a20,\n        b00 * a01 + b01 * a11 + b02 * a21,\n        b00 * a02 + b01 * a12 + b02 * a22,\n        b10 * a00 + b11 * a10 + b12 * a20,\n        b10 * a01 + b11 * a11 + b12 * a21,\n        b10 * a02 + b11 * a12 + b12 * a22,\n        b20 * a00 + b21 * a10 + b22 * a20,\n        b20 * a01 + b21 * a11 + b22 * a21,\n        b20 * a02 + b21 * a12 + b22 * a22\n    ];\n}\n\n\n//# sourceURL=webpack://corona-webgl/./src/util/math.ts?\n}");

/***/ },

/***/ "./src/util/webgl.ts"
/*!***************************!*\
  !*** ./src/util/webgl.ts ***!
  \***************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileProgram: () => (/* binding */ compileProgram),\n/* harmony export */   compileShader: () => (/* binding */ compileShader),\n/* harmony export */   resizeCanvasToDisplaySize: () => (/* binding */ resizeCanvasToDisplaySize)\n/* harmony export */ });\n/**\n * Compiles a shader using the corresponding source code. Courtesy of WebGL\n * fundamentals.\n *\n * @param   {WebGL2RenderingContext}  gl      WebGL Context\n * @param   {'vertex'|'fragment'}     type    The shader type\n * @param   {string}                  source  The source code\n *\n * @returns {WebGLShader}                     The compiled shader\n */\nfunction compileShader(gl, type, source) {\n    const glType = type === 'vertex' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n    const shader = gl.createShader(glType);\n    if (shader === null) {\n        throw new Error('Could not create shader from WebGL Context!');\n    }\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n        return shader;\n    }\n    const msg = `Error compiling \"${type}\" shader: ${gl.getShaderInfoLog(shader)}`;\n    gl.deleteShader(shader);\n    throw new Error(msg);\n}\n/**\n * Takes two shaders and links them to a program. Courtesy of WebGL\n * fundamentals.\n *\n * @param   {WebGL2RenderingContext}  gl              The WebGL context\n * @param   {WebGLShader}             vertexShader    The Vertex shader\n * @param   {WebGLShader}             fragmentShader  The Fragment shader\n *\n * @return  {WebGLProgram}                            The program\n */\nfunction compileProgram(gl, vertexShader, fragmentShader) {\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n        return program;\n    }\n    const msg = `Could not link program: ${gl.getProgramInfoLog(program)}`;\n    gl.deleteProgram(program);\n    throw new Error(msg);\n}\n/**\n * Utility function that resizes a canvas size to its actual dimensions.\n * Courtesy of WebGL fundamentals.\n *\n * @param  {HTMLCanvasElement}  canvas  The canvas to check\n */\nfunction resizeCanvasToDisplaySize(canvas) {\n    // Lookup the size the browser is displaying the canvas in CSS pixels.\n    const displayWidth = canvas.clientWidth;\n    const displayHeight = canvas.clientHeight;\n    // Check if the canvas is not the same size.\n    const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n    if (needResize) {\n        // Make the canvas the same size\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n    }\n    return needResize;\n}\n\n\n//# sourceURL=webpack://corona-webgl/./src/util/webgl.ts?\n}");

/***/ },

/***/ "./src/webgl-engine.ts"
/*!*****************************!*\
  !*** ./src/webgl-engine.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebGLEngine: () => (/* binding */ WebGLEngine)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"./src/index.ts\");\n/* harmony import */ var _util_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/webgl */ \"./src/util/webgl.ts\");\n/* harmony import */ var _shaders_vertex_shader_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/vertex_shader.glsl */ \"./src/shaders/vertex_shader.glsl\");\n/* harmony import */ var _shaders_fragment_shader_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/fragment_shader.glsl */ \"./src/shaders/fragment_shader.glsl\");\n\n\n\n\n// NOTE that this color is currently set to an alpha of 0 to allow varying\n// background colors (if so wished, but let me tell you it looks awful with\n// anything too bright).\nconst BACKGROUND_COLOR = [0.3, 0.3, 0.4, 0.0];\n// This is effectively unused. I kept it here to remember the difference between\n// \"regular\" and HDR textures (see the code below).\nconst USE_HDR_TEXTURES = true;\n// Enum that must be defined the same way in the WebGL code and the shaders\nconst FRAGMENT_PASS_PASSTHROUGH = 0.0;\nconst FRAGMENT_PASS_NORMAL = 1.0;\nconst FRAGMENT_PASS_BLUR = 2.0;\nconst FRAGMENT_PASS_COMPOSITE = 3.0;\nconst FRAGMENT_PASS_TONEMAP = 4.0;\nconst FRAGMENT_PASS_BRIGHTNESS = 5.0;\n/**\n * This class handles all the nitty-gritty of the WebGL code and ensures our\n * rays and the rest of the indicator are properly rendered onto the canvas.\n */\nclass WebGLEngine {\n    constructor(gl) {\n        this.gl = gl;\n        // Set some defaults\n        this.bloomEnabled = true;\n        this.nBloomPasses = 32;\n        this.msaaEnabled = true;\n        this.hdrFactor = 10.0;\n        this.textureSizeModifier = Math.min(window.devicePixelRatio, 2);\n        // Compile shaders and make a program from them\n        const vertexShader = (0,_util_webgl__WEBPACK_IMPORTED_MODULE_1__.compileShader)(this.gl, 'vertex', _shaders_vertex_shader_glsl__WEBPACK_IMPORTED_MODULE_2__);\n        const fragmentShader = (0,_util_webgl__WEBPACK_IMPORTED_MODULE_1__.compileShader)(this.gl, 'fragment', _shaders_fragment_shader_glsl__WEBPACK_IMPORTED_MODULE_3__);\n        // Load the actual program\n        this.program = (0,_util_webgl__WEBPACK_IMPORTED_MODULE_1__.compileProgram)(this.gl, vertexShader, fragmentShader);\n        // Set up the program and provide data\n        gl.useProgram(this.program);\n        // This is our custom global attribute state\n        this.vao = gl.createVertexArray();\n        gl.bindVertexArray(this.vao);\n        // Set the global clear color, which effectively is the background color.\n        const [r, g, b, a] = BACKGROUND_COLOR;\n        gl.clearColor(r, g, b, a);\n        // We want to enable EXT_color_buffer_float to be able to render HDR\n        // textures. Why do we need to \"get\" it, instead of \"activating\" or so? I\n        // don't know.\n        gl.getExtension('EXT_color_buffer_float');\n        // Create a buffer for the coordinates of the rays\n        this.positionBuffer = gl.createBuffer();\n        // Extract memory addresses for the program variables. The strings are the\n        // variable names as defined in the GLSL shaders.\n        this.resolutionUniformLocation = gl.getUniformLocation(this.program, 'u_resolution');\n        this.positionAttributeLocation = gl.getAttribLocation(this.program, 'a_position');\n        this.matrixUniformLocation = gl.getUniformLocation(this.program, 'u_matrix');\n        this.passUniformLocation = gl.getUniformLocation(this.program, 'u_pass');\n        this.blurTexUniformLocation = gl.getUniformLocation(this.program, 'u_blurTexture');\n        this.blurHorizontalUniformLocation = gl.getUniformLocation(this.program, 'u_blur_horizontal');\n        this.blendRatioUniformLocation = gl.getUniformLocation(this.program, 'u_blendRatio');\n        // Set up the color structs. Since GLSL is a bit iffy, we have to actually\n        // address each of the actual hardcoded values individually, thus we store\n        // them in an array here.\n        // @ts-expect-error We will fill this with exact four entries below\n        this.segmentLocs = [];\n        for (let i = 0; i < ___WEBPACK_IMPORTED_MODULE_0__.MAX_SUPPORTED_SEGMENTS; i++) {\n            this.segmentLocs.push({\n                ratio: gl.getUniformLocation(this.program, `u_segments[${i}].ratio`),\n                color: gl.getUniformLocation(this.program, `u_segments[${i}].color`)\n            });\n        }\n        // Configure our vertices\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.enableVertexAttribArray(this.positionAttributeLocation); // Mark the buffer as a vertex array\n        // Positions are x/y coordinates (two components)\n        gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n        // Now we need our texture size to generate some textures and render\n        // buffers. We also define some defaults for our textures (these are copied\n        // to the onResize handler).\n        const { cWidth, cHeight } = this.textureSize();\n        const internalFormat = USE_HDR_TEXTURES ? gl.RGBA16F : gl.RGBA;\n        const format = gl.RGBA;\n        const type = USE_HDR_TEXTURES ? gl.FLOAT : gl.UNSIGNED_BYTE;\n        // Setup the ping-pong framebuffers for postprocessing\n        this.pingpong = [\n            { fb: gl.createFramebuffer(), rbuf: this.createTexture() },\n            { fb: gl.createFramebuffer(), rbuf: this.createTexture() }\n        ];\n        for (let i = 0; i < this.pingpong.length; i++) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this.pingpong[i].fb);\n            gl.bindTexture(gl.TEXTURE_2D, this.pingpong[i].rbuf);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, cWidth, cHeight, 0, format, type, null);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingpong[i].rbuf, 0);\n        }\n        // Setup the scene target framebuffer\n        // Includes a framebuffer for Multisample Anti-Aliasing (MSAA)\n        // Courtesy of https://stackoverflow.com/questions/47934444/webgl-framebuffer-multisampling\n        this.scenetarget = {\n            // Regular framebuffer + regular texture\n            fb: gl.createFramebuffer(),\n            scene: this.createTexture(),\n            // MSAA framebuffer + renderbuffer\n            fbMSAA: gl.createFramebuffer(),\n            rbMSAA: gl.createRenderbuffer()\n        };\n        console.log(`INFO: WebGL can run MSAA at ${gl.getParameter(gl.MAX_SAMPLES)}x.`);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.scenetarget.fbMSAA);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this.scenetarget.rbMSAA);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gl.getParameter(gl.MAX_SAMPLES), internalFormat, cWidth, cHeight);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.scenetarget.rbMSAA);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.scenetarget.fb);\n        gl.bindTexture(gl.TEXTURE_2D, this.scenetarget.scene);\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, cWidth, cHeight, 0, format, type, null);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.scenetarget.scene, 0);\n        // Reset the state (because WebGL is REALLY iffy if a texture or framebuffer\n        // is bound and is then used as a render target. This was actually one of\n        // the most common errors I had.)\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n    /**\n     * Enables or disables bloom effect.\n     *\n     * @param  {boolean}  enabled  Whether bloom should be enabled\n     */\n    setBloomEnabled(enabled) {\n        this.bloomEnabled = enabled;\n    }\n    /**\n     * Sets the intensity of bloom to be applied.\n     *\n     * @param  {number}  intensity  The intensity to use. Higher numbers are more bloomy results.\n     */\n    setBloomIntensity(intensity) {\n        this.nBloomPasses = intensity * 8; // 8, 16, 32, 64\n    }\n    /**\n     * Enables or disables MSAA.\n     *\n     * @param   {boolean}  enabled  Whether MSAA should run\n     */\n    setMSAAEnabled(enabled) {\n        this.msaaEnabled = enabled;\n    }\n    /**\n     * Determines how large textures are being rendered. By default, this uses the\n     * device's pixel ratio (window.devicePixelRatio), but it can be overridden.\n     * The larger the textures, the more resource-intensive.\n     *\n     * @param   {number}  mod  The new modifier. Should be 1, 2, 3, 4, or so.\n     */\n    setTextureSizeModifier(mod) {\n        this.textureSizeModifier = Math.min(mod, 2);\n        this.onResize();\n    }\n    /**\n     * Sets the color segments. Allows up to four segments.\n     *\n     * @param  {Vec4<{ color: number[], ratio: number }>}  segments  The new segments\n     */\n    setSegments(segments) {\n        const gl = this.gl;\n        for (let i = 0; i < ___WEBPACK_IMPORTED_MODULE_0__.MAX_SUPPORTED_SEGMENTS; i++) {\n            const seg = segments[i % segments.length];\n            let [r, g, b, a] = seg.color;\n            r *= this.hdrFactor;\n            g *= this.hdrFactor;\n            b *= this.hdrFactor;\n            gl.uniform4fv(this.segmentLocs[i].color, [r, g, b, a]);\n            gl.uniform1f(this.segmentLocs[i].ratio, seg.ratio);\n        }\n        // Calculate the blend ratio.\n        let blendRatio = Infinity;\n        for (const { ratio } of segments) {\n            if (ratio === 0.0) {\n                continue;\n            }\n            if (ratio < blendRatio) {\n                blendRatio = ratio;\n            }\n        }\n        blendRatio /= 2.0; // Half of the smallest ratio\n        blendRatio = Math.max(Math.min(blendRatio, 0.1), 0.01); // Clamp between 1% and 10%\n        gl.uniform1f(this.blendRatioUniformLocation, blendRatio);\n    }\n    /**\n     * Whenever the canvas size changes, we must call this routine to re-configure\n     * all textures and framebuffers. Otherwise, all hell will break loose.\n     */\n    onResize() {\n        const gl = this.gl;\n        const { cWidth, cHeight } = this.textureSize();\n        const internalFormat = USE_HDR_TEXTURES ? gl.RGBA16F : gl.RGBA;\n        const format = gl.RGBA;\n        const type = USE_HDR_TEXTURES ? gl.FLOAT : gl.UNSIGNED_BYTE;\n        for (const { rbuf } of this.pingpong) {\n            gl.bindTexture(gl.TEXTURE_2D, rbuf);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, cWidth, cHeight, 0, format, type, null);\n        }\n        gl.bindTexture(gl.TEXTURE_2D, this.scenetarget.scene);\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, cWidth, cHeight, 0, format, type, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this.scenetarget.rbMSAA);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gl.getParameter(gl.MAX_SAMPLES), internalFormat, cWidth, cHeight);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    }\n    /**\n     * Creates textures with some defaults. Courtesy of WebGL fundamentals.\n     *\n     * @return  {WebGLTexture}  The created and configured texture.\n     */\n    createTexture() {\n        const gl = this.gl;\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // Set up texture so we can render any size image and so we are\n        // working with pixels.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        // If we set these two, linear interpolation won't work for that texture\n        // anymore.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        return texture;\n    }\n    /**\n     * Set a given framebuffer including a viewport setting. Courtesy of WebGL\n     * fundamentals.\n     *\n     * @param {WebGLFramebuffer|null} fbo\n     * @param {number} width\n     * @param {number} height\n     */\n    setFramebuffer(fbo, width, height, variant = 'both') {\n        const gl = this.gl;\n        switch (variant) {\n            case 'read':\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo);\n                break;\n            case 'draw':\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fbo);\n                break;\n            default:\n                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n                break;\n        }\n        gl.uniform2f(this.resolutionUniformLocation, width, height);\n        gl.viewport(0, 0, width, height);\n    }\n    /**\n     * Returns the wanted texture size. NOTE that this is NOT the same as the\n     * canvas size. Higher texture sizes are more performance-heavy, but can\n     * result in smoother results.\n     *\n     * @return  {{ cWidth: number, cHeight: number }}  The wanted size\n     */\n    textureSize() {\n        const gl = this.gl;\n        // @ts-ignore\n        const cWidth = Math.ceil(gl.canvas.clientWidth * this.textureSizeModifier);\n        // @ts-ignore\n        const cHeight = Math.ceil(gl.canvas.clientHeight * this.textureSizeModifier);\n        return { cWidth, cHeight };\n    }\n    /**\n     * Expects a bunch of coordinates (pixels) and accompanying colors. This\n     * function is called by the Iris Indicator to perform the actual rendering.\n     *\n     * @param {Float32Array} triangleData\n     * @param {number} count\n     * @param {number[]} matrix\n     */\n    draw(triangleData, count, matrix) {\n        const gl = this.gl;\n        const { cWidth, cHeight } = this.textureSize();\n        // Ensure the canvas has the correct size\n        (0,_util_webgl__WEBPACK_IMPORTED_MODULE_1__.resizeCanvasToDisplaySize)(gl.canvas);\n        // Clear the buffer\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        // Activate our attribute state\n        gl.bindVertexArray(this.vao);\n        // FIRST PASS: Draw our rays onto the scene target\n        // =========================================================================\n        // The first pass uses the scenetarget framebuffer with two attached\n        // textures. The first one will hold the actual texture, the second one\n        // holds the brightness information.\n        if (this.msaaEnabled) {\n            this.setFramebuffer(this.scenetarget.fbMSAA, cWidth, cHeight);\n        }\n        else {\n            this.setFramebuffer(this.scenetarget.fb, cWidth, cHeight);\n        }\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        // Tell the shaders we are doing the first pass.\n        gl.uniform1f(this.passUniformLocation, FRAGMENT_PASS_NORMAL);\n        // Write projection/scaling/etc. matrix\n        gl.uniformMatrix3fv(this.matrixUniformLocation, false, matrix);\n        // Write position data and draw the rays\n        gl.bufferData(gl.ARRAY_BUFFER, triangleData, gl.DYNAMIC_DRAW);\n        gl.drawArrays(gl.TRIANGLES, 0, count);\n        // POST-PROCESSING PASSES\n        // =========================================================================\n        // Here, we pass the rendered image through all necessary additional effects.\n        // First: MSAA.\n        if (this.msaaEnabled) {\n            // We now need to blit both render buffers into the scene targets.\n            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.scenetarget.fbMSAA);\n            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.scenetarget.fb);\n            gl.blitFramebuffer(0, 0, cWidth, cHeight, 0, 0, cWidth, cHeight, gl.COLOR_BUFFER_BIT, gl.LINEAR);\n            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n        }\n        this.setFramebuffer(this.scenetarget.fb, cWidth, cHeight);\n        // Apply a bloom filter if applicable\n        let outputTexture = this.bloomEnabled\n            ? this.bloomPass(this.scenetarget.scene, this.nBloomPasses)\n            : this.scenetarget.scene;\n        // Ensure we are writing to the rectangle\n        this.setFramebufferRectangle(cWidth, cHeight);\n        // Tone-mapping\n        gl.bindTexture(gl.TEXTURE_2D, outputTexture);\n        this.setFramebuffer(this.pingpong[1].fb, cWidth, cHeight);\n        gl.uniform1f(this.passUniformLocation, FRAGMENT_PASS_TONEMAP);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        outputTexture = this.pingpong[1].rbuf;\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        // Finally, draw the finished image onto the canvas by setting framebuffer\n        // to null (= the canvas).\n        // @ts-ignore WebGL can also run in a hidden canvas w/o clientWidth/height.\n        this.setFramebuffer(null, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight);\n        gl.bindTexture(gl.TEXTURE_2D, outputTexture);\n        gl.uniform1f(this.passUniformLocation, FRAGMENT_PASS_PASSTHROUGH);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n    /**\n     * Performs a blur pass across the provides source texture. This uses the\n     * \"ping pong\" strategy to progressively apply blur to the image.\n     *\n     * @param   {WebGLTexture}  sourceTexture  The image to be \"bloomed.\"\n     *\n     * @return  {WebGLTexture}                 The texture to which the bloom has\n     *                                         been applied.\n     */\n    bloomPass(sourceTexture, nPasses = 32) {\n        const gl = this.gl;\n        const { cWidth, cHeight } = this.textureSize();\n        // Apply the rectangle to draw the texture to (instead of our rays)\n        this.setFramebufferRectangle(cWidth, cHeight);\n        // Before anything, we need to produce a brightness map based on the source\n        // texture. For this, we bind the SECOND ping pong, provide it the source\n        // texture, and let the shader extract the brightness information. NOTE that\n        // the brightness filter requires very bright HDR-colors, since it will only\n        // extract the colors for a luminosity of >1.0.\n        this.setFramebuffer(this.pingpong[1].fb, cWidth, cHeight);\n        gl.bindTexture(gl.TEXTURE_2D, sourceTexture);\n        gl.uniform1f(this.passUniformLocation, FRAGMENT_PASS_BRIGHTNESS);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        gl.bindTexture(gl.TEXTURE_2D, this.pingpong[1].rbuf);\n        // Switch the fragment shader to blur-passing\n        gl.uniform1f(this.passUniformLocation, FRAGMENT_PASS_BLUR);\n        // Remember the last active texture from the pingpong pass so that we\n        // extract the correct, final image. This allows us to customize what we\n        // want to do with the pingpong buffers before entering the rendering loop.\n        let lastActiveTexture = 0;\n        // Use the brightness-map to blur. We run nPasses * 2 times, because each\n        // blur requires two passes over the image, once horizontally, and once\n        // vertically.\n        for (let pass = 0; pass < nPasses * 2; pass++) {\n            // Tell the shader into which direction we should apply the blur.\n            gl.uniform1i(this.blurHorizontalUniformLocation, pass % 2);\n            this.setFramebuffer(this.pingpong[pass % 2].fb, cWidth, cHeight);\n            gl.drawArrays(gl.TRIANGLES, 0, 6); // 6 coordinates\n            // Set the texture from the current framebuffer as the active one to use\n            // in the next pass.\n            gl.bindTexture(gl.TEXTURE_2D, this.pingpong[pass % 2].rbuf);\n            lastActiveTexture = pass % 2; //\n        }\n        // NOTE: Perform a xor, since 0^1==1 and  1^1==0\n        this.setFramebuffer(this.pingpong[lastActiveTexture ^ 1].fb, cWidth, cHeight);\n        // Third step of the blooming: Merge the blurred one with the original\n        // source image to produce the final result.\n        gl.uniform1f(this.passUniformLocation, FRAGMENT_PASS_COMPOSITE);\n        // For this final pass, the fragment shader needs two images. Specifically,\n        // first the original source texture, and then the blurred image from the\n        // ping-pong stage.\n        gl.bindTexture(gl.TEXTURE_2D, sourceTexture);\n        gl.activeTexture(gl.TEXTURE0 + 1);\n        gl.bindTexture(gl.TEXTURE_2D, this.pingpong[lastActiveTexture].rbuf);\n        gl.uniform1i(this.blurTexUniformLocation, 1);\n        // Draw the composite image\n        gl.drawArrays(gl.TRIANGLES, 0, 6); // 6 coordinates\n        // Unbind textures again (because textures bound to one of the texture\n        // points cannot be written to by the framebuffers in our next render pass).\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        // Return the texture we've written to so that other calls can use it.\n        return this.pingpong[lastActiveTexture ^ 1].rbuf;\n    }\n    /**\n     * Very simple routine to write the coordinates for a full-screen rectangle\n     * into the vertex buffer. NOTE: This requires the position buffer to be\n     * bound. Currently, we only have a single buffer, so this will work, but if\n     * we ever add more vertex buffers, this becomes important.\n     *\n     * @param  {number}  width   The width of the rectangle\n     * @param  {number}  height  The height of the rectangle\n     */\n    setFramebufferRectangle(width, height) {\n        // Two triangles to make a rectangle\n        const coords = new Float32Array([\n            0.0, 0.0, width, 0.0, width, height,\n            0.0, 0.0, width, height, 0.0, height\n        ]);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, coords, this.gl.STATIC_DRAW);\n    }\n}\n\n\n//# sourceURL=webpack://corona-webgl/./src/webgl-engine.ts?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/iris-indicator.ts");
/******/ 	
/******/ })()
;